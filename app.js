const translations = {
  bn: {
    nav_home: "Home",
    nav_convert: "Converter",
    nav_table: "ASCII Table",
    nav_menu: "Menu",
    hero_tag: "ASCII Utility Studio",
    hero_title: "ASCII টেবিল, কনভার্সন, আর এক ফর্ম থেকে আরেক ফর্মে রূপান্তর।",
    hero_desc: "দ্রুত টেক্সট ↔ ASCII, বাইনারি, হেক্স আর অক্টাল। বোল্ড কিন্তু পরিষ্কার UI।",
    hero_cta_primary: "কনভার্ট করুন",
    hero_cta_secondary: "ASCII টেবিল দেখুন",
    hero_card_title: "Quick Example",
    feat_one_title: "Text → ASCII",
    feat_one_desc: "প্রতিটি অক্ষরের decimal ASCII কোড বের করুন।",
    feat_two_title: "ASCII → Text",
    feat_two_desc: "Comma বা space দিয়ে আলাদা করা সংখ্যা থেকে টেক্সট।",
    feat_three_title: "Binary / Hex / Octal",
    feat_three_desc: "৮-বিট বাইনারি, হেক্স আর অক্টাল দুই দিকেই কনভার্ট করুন।",
    footer_text: "Made for ASCII learning and conversions.",
    convert_title: "ASCII Converter",
    convert_desc: "টেক্সটকে ASCII, বাইনারি, হেক্স, অক্টালে রূপান্তর করুন এবং ফিরিয়ে আনুন।",
    panel_text_ascii: "Text → ASCII",
    panel_ascii_text: "ASCII → Text",
    panel_text_bin: "Text → Binary",
    panel_bin_text: "Binary → Text",
    panel_text_hex: "Text → Hex",
    panel_hex_text: "Hex → Text",
    panel_text_octal: "Text → Octal",
    panel_octal_text: "Octal → Text",
    smart_title: "Smart Converter",
    smart_desc: "ফরম্যাট বাছাই করুন, swap করুন, আর দ্রুত কনভার্ট করুন।",
    btn_copy: "Copy",
    btn_convert: "Convert",
    btn_download: "Download",
    btn_swap: "Swap",
    label_from: "From",
    label_to: "To",
    opt_text: "Text",
    opt_ascii: "ASCII (dec)",
    opt_binary: "Binary",
    opt_hex: "Hex",
    opt_octal: "Octal",
    theme_dark: "Dark mode",
    theme_light: "Light mode",
    ph_smart_input: "এখানে লিখুন বা পেস্ট করুন...",
    ph_smart_output: "কনভার্টেড আউটপুট...",
    ph_text: "এখানে টেক্সট লিখুন...",
    ph_ascii: "ASCII আউটপুট...",
    ph_ascii_input: "72, 101, 108...",
    ph_text_output: "টেক্সট আউটপুট...",
    ph_binary: "Binary আউটপুট...",
    ph_binary_input: "01001000 01100101...",
    ph_hex: "Hex আউটপুট...",
    ph_hex_input: "48 65 6C 6C 6F",
    ph_octal: "Octal আউটপুট...",
    ph_octal_input: "110 145 154 154 157",
    ph_table_search: "কোড বা ক্যারেক্টার সার্চ করুন...",
    note_title: "Input Tips",
    note_desc: "ASCII/hex/octal ইনপুটে comma, space, বা new line দিয়ে সংখ্যা আলাদা করতে পারবেন। Binary ইনপুটে ৮-বিট ব্লক (যেমন 01000001) ব্যবহার করুন।",
    table_title: "ASCII Table",
    table_desc: "0-127 পর্যন্ত স্ট্যান্ডার্ড ASCII কোড, decimal, hex, binary এবং চরিত্রসহ।",
    range_all: "All (0-127)",
    range_printable: "Printable (32-126)",
    th_dec: "Dec",
    th_hex: "Hex",
    th_bin: "Binary",
    th_char: "Char",
    th_desc: "Description"
  },
  en: {
    nav_home: "Home",
    nav_convert: "Converter",
    nav_table: "ASCII Table",
    nav_menu: "Menu",
    hero_tag: "ASCII Utility Studio",
    hero_title: "ASCII table, conversions, and form-to-form transforms.",
    hero_desc: "Fast text ↔ ASCII, binary, hex, and octal in a bold, clean interface.",
    hero_cta_primary: "Start Converting",
    hero_cta_secondary: "View ASCII Table",
    hero_card_title: "Quick Example",
    feat_one_title: "Text → ASCII",
    feat_one_desc: "Get decimal ASCII codes for each character.",
    feat_two_title: "ASCII → Text",
    feat_two_desc: "Turn comma or space separated numbers into text.",
    feat_three_title: "Binary / Hex / Octal",
    feat_three_desc: "Convert 8-bit binary, hex, and octal in both directions.",
    footer_text: "Made for ASCII learning and conversions.",
    convert_title: "ASCII Converter",
    convert_desc: "Convert text to ASCII, binary, hex, or octal and back again.",
    panel_text_ascii: "Text → ASCII",
    panel_ascii_text: "ASCII → Text",
    panel_text_bin: "Text → Binary",
    panel_bin_text: "Binary → Text",
    panel_text_hex: "Text → Hex",
    panel_hex_text: "Hex → Text",
    panel_text_octal: "Text → Octal",
    panel_octal_text: "Octal → Text",
    smart_title: "Smart Converter",
    smart_desc: "Pick formats, swap, and convert instantly.",
    btn_copy: "Copy",
    btn_convert: "Convert",
    btn_download: "Download",
    btn_swap: "Swap",
    label_from: "From",
    label_to: "To",
    opt_text: "Text",
    opt_ascii: "ASCII (dec)",
    opt_binary: "Binary",
    opt_hex: "Hex",
    opt_octal: "Octal",
    theme_dark: "Dark mode",
    theme_light: "Light mode",
    ph_smart_input: "Type or paste here...",
    ph_smart_output: "Converted output...",
    ph_text: "Type text here...",
    ph_ascii: "ASCII output...",
    ph_ascii_input: "72, 101, 108...",
    ph_text_output: "Text output...",
    ph_binary: "Binary output...",
    ph_binary_input: "01001000 01100101...",
    ph_hex: "Hex output...",
    ph_hex_input: "48 65 6C 6C 6F",
    ph_octal: "Octal output...",
    ph_octal_input: "110 145 154 154 157",
    ph_table_search: "Search by code or character...",
    note_title: "Input Tips",
    note_desc: "ASCII/hex/octal input accepts comma, space, or new-line separated numbers. Binary input expects 8-bit blocks (e.g., 01000001).",
    table_title: "ASCII Table",
    table_desc: "Standard ASCII codes 0-127 with decimal, hex, binary, and character.",
    range_all: "All (0-127)",
    range_printable: "Printable (32-126)",
    th_dec: "Dec",
    th_hex: "Hex",
    th_bin: "Binary",
    th_char: "Char",
    th_desc: "Description"
  }
};

const controlNames = {
  0: "NUL",
  1: "SOH",
  2: "STX",
  3: "ETX",
  4: "EOT",
  5: "ENQ",
  6: "ACK",
  7: "BEL",
  8: "BS",
  9: "TAB",
  10: "LF",
  11: "VT",
  12: "FF",
  13: "CR",
  14: "SO",
  15: "SI",
  16: "DLE",
  17: "DC1",
  18: "DC2",
  19: "DC3",
  20: "DC4",
  21: "NAK",
  22: "SYN",
  23: "ETB",
  24: "CAN",
  25: "EM",
  26: "SUB",
  27: "ESC",
  28: "FS",
  29: "GS",
  30: "RS",
  31: "US",
  127: "DEL"
};

const state = {
  lang: "en",
  theme: "light"
};

const setLanguage = (lang) => {
  state.lang = lang;
  document.documentElement.lang = lang === "bn" ? "bn" : "en";
  document.querySelectorAll("[data-i18n]").forEach((el) => {
    const key = el.getAttribute("data-i18n");
    if (translations[lang][key]) {
      el.textContent = translations[lang][key];
    }
  });
  document.querySelectorAll("[data-i18n-placeholder]").forEach((el) => {
    const key = el.getAttribute("data-i18n-placeholder");
    if (translations[lang][key]) {
      el.setAttribute("placeholder", translations[lang][key]);
    }
  });
  updateThemeToggleText();
};

const applyTheme = (theme) => {
  state.theme = theme;
  document.documentElement.setAttribute("data-theme", theme);
  localStorage.setItem("ascii-theme", theme);
};

const updateThemeToggleText = () => {
  const toggle = document.getElementById("themeToggle");
  if (!toggle) return;
  const key = state.theme === "dark" ? "theme_light" : "theme_dark";
  toggle.textContent = translations[state.lang][key];
};

const initTheme = () => {
  const saved = localStorage.getItem("ascii-theme");
  if (saved === "dark" || saved === "light") {
    applyTheme(saved);
    return;
  }
  const prefersDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
  applyTheme(prefersDark ? "dark" : "light");
};

const copyToClipboard = async (text) => {
  if (!text) return;
  try {
    await navigator.clipboard.writeText(text);
  } catch (err) {
    console.warn("Copy failed", err);
  }
};

const textToAscii = (text) => {
  return Array.from(text)
    .map((char) => char.charCodeAt(0))
    .join(", ");
};

const asciiToText = (raw) => {
  const nums = raw
    .trim()
    .split(/[\s,]+/)
    .filter(Boolean)
    .map((value) => Number(value));

  return nums
    .map((code) => (Number.isFinite(code) ? String.fromCharCode(code) : ""))
    .join("");
};

const textToBinary = (text) => {
  return Array.from(text)
    .map((char) => char.charCodeAt(0).toString(2).padStart(8, "0"))
    .join(" ");
};

const textToHex = (text) => {
  return Array.from(text)
    .map((char) => char.charCodeAt(0).toString(16).toUpperCase().padStart(2, "0"))
    .join(" ");
};

const textToOctal = (text) => {
  return Array.from(text)
    .map((char) => char.charCodeAt(0).toString(8).padStart(3, "0"))
    .join(" ");
};

const binaryToText = (raw) => {
  const parts = raw
    .trim()
    .split(/[\s,]+/)
    .filter(Boolean);

  return parts
    .map((bin) => {
      const code = parseInt(bin, 2);
      return Number.isFinite(code) ? String.fromCharCode(code) : "";
    })
    .join("");
};

const hexToText = (raw) => {
  const parts = raw
    .trim()
    .split(/[\s,]+/)
    .filter(Boolean)
    .map((value) => value.replace(/^0x/i, ""));

  return parts
    .map((hex) => {
      const code = parseInt(hex, 16);
      return Number.isFinite(code) ? String.fromCharCode(code) : "";
    })
    .join("");
};

const octalToText = (raw) => {
  const parts = raw
    .trim()
    .split(/[\s,]+/)
    .filter(Boolean);

  return parts
    .map((oct) => {
      const code = parseInt(oct, 8);
      return Number.isFinite(code) ? String.fromCharCode(code) : "";
    })
    .join("");
};

const toText = (type, raw) => {
  switch (type) {
    case "text":
      return raw;
    case "ascii":
      return asciiToText(raw);
    case "binary":
      return binaryToText(raw);
    case "hex":
      return hexToText(raw);
    case "octal":
      return octalToText(raw);
    default:
      return raw;
  }
};

const fromText = (type, text) => {
  switch (type) {
    case "text":
      return text;
    case "ascii":
      return textToAscii(text);
    case "binary":
      return textToBinary(text);
    case "hex":
      return textToHex(text);
    case "octal":
      return textToOctal(text);
    default:
      return text;
  }
};

const convertSmart = () => {
  const fromSelect = document.getElementById("smartFrom");
  const toSelect = document.getElementById("smartTo");
  const input = document.getElementById("smartInput");
  const output = document.getElementById("smartOutput");
  if (!fromSelect || !toSelect || !input || !output) return;

  const raw = input.value;
  if (!raw.trim()) {
    output.value = "";
    return;
  }

  const text = toText(fromSelect.value, raw);
  output.value = fromText(toSelect.value, text);
};

const swapSmart = () => {
  const fromSelect = document.getElementById("smartFrom");
  const toSelect = document.getElementById("smartTo");
  const input = document.getElementById("smartInput");
  const output = document.getElementById("smartOutput");
  if (!fromSelect || !toSelect || !input || !output) return;

  const temp = fromSelect.value;
  fromSelect.value = toSelect.value;
  toSelect.value = temp;

  if (output.value.trim()) {
    input.value = output.value;
  }
  convertSmart();
};

const updateOutput = (inputId, outputId, converter) => {
  const input = document.getElementById(inputId);
  const output = document.getElementById(outputId);
  if (!input || !output) return;
  const raw = input.value;
  output.value = raw.trim() ? converter(raw) : "";
};

const downloadText = (text, filename) => {
  if (!text) return;
  const blob = new Blob([text], { type: "text/plain" });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = filename || "output.txt";
  link.click();
  URL.revokeObjectURL(link.href);
};

const bindConverters = () => {
  const actions = {
    textToAscii: () => {
      updateOutput("textToAsciiInput", "textToAsciiOutput", textToAscii);
    },
    asciiToText: () => {
      updateOutput("asciiToTextInput", "asciiToTextOutput", asciiToText);
    },
    textToBinary: () => {
      updateOutput("textToBinaryInput", "textToBinaryOutput", textToBinary);
    },
    binaryToText: () => {
      updateOutput("binaryToTextInput", "binaryToTextOutput", binaryToText);
    },
    textToHex: () => {
      updateOutput("textToHexInput", "textToHexOutput", textToHex);
    },
    hexToText: () => {
      updateOutput("hexToTextInput", "hexToTextOutput", hexToText);
    },
    textToOctal: () => {
      updateOutput("textToOctalInput", "textToOctalOutput", textToOctal);
    },
    octalToText: () => {
      updateOutput("octalToTextInput", "octalToTextOutput", octalToText);
    },
    smartConvert: () => {
      convertSmart();
    },
    smartChange: () => {
      convertSmart();
    },
    swapSmart: () => {
      swapSmart();
    },
    toggleTheme: () => {
      applyTheme(state.theme === "dark" ? "light" : "dark");
      updateThemeToggleText();
    }
  };

  document.querySelectorAll("[data-action]").forEach((btn) => {
    const action = btn.getAttribute("data-action");
    btn.addEventListener("click", () => {
      if (action === "copy") {
        const targetId = btn.getAttribute("data-target");
        const target = document.getElementById(targetId);
        if (target) copyToClipboard(target.value);
        return;
      }
      if (action === "download") {
        const targetId = btn.getAttribute("data-target");
        const filename = btn.getAttribute("data-filename");
        const target = document.getElementById(targetId);
        if (target) downloadText(target.value, filename);
        return;
      }
      if (actions[action]) actions[action]();
    });
  });

  const autoConvertMap = [
    ["textToAsciiInput", "textToAscii"],
    ["asciiToTextInput", "asciiToText"],
    ["textToBinaryInput", "textToBinary"],
    ["binaryToTextInput", "binaryToText"],
    ["textToHexInput", "textToHex"],
    ["hexToTextInput", "hexToText"],
    ["textToOctalInput", "textToOctal"],
    ["octalToTextInput", "octalToText"]
  ];

  autoConvertMap.forEach(([inputId, actionName]) => {
    const input = document.getElementById(inputId);
    if (!input || !actions[actionName]) return;
    input.addEventListener("input", actions[actionName]);
  });

  const smartInput = document.getElementById("smartInput");
  const smartFrom = document.getElementById("smartFrom");
  const smartTo = document.getElementById("smartTo");
  if (smartInput) smartInput.addEventListener("input", convertSmart);
  if (smartFrom) smartFrom.addEventListener("change", convertSmart);
  if (smartTo) smartTo.addEventListener("change", convertSmart);
};

const createTableRow = (code) => {
  const char = code >= 32 && code <= 126 ? String.fromCharCode(code) : "";
  const desc = controlNames[code] || (char ? "Printable" : "Control");
  return `
    <tr data-code="${code}">
      <td>${code}</td>
      <td>${code.toString(16).toUpperCase().padStart(2, "0")}</td>
      <td>${code.toString(2).padStart(8, "0")}</td>
      <td>${char || "—"}</td>
      <td>${desc}</td>
    </tr>
  `;
};

const renderTable = () => {
  const body = document.getElementById("asciiTableBody");
  if (!body) return;

  const rows = [];
  for (let i = 0; i <= 127; i += 1) {
    rows.push(createTableRow(i));
  }
  body.innerHTML = rows.join("");
};

const filterTable = () => {
  const body = document.getElementById("asciiTableBody");
  const searchInput = document.getElementById("tableSearch");
  const rangeSelect = document.getElementById("rangeSelect");
  if (!body || !searchInput || !rangeSelect) return;

  const query = searchInput.value.trim().toLowerCase();
  const range = rangeSelect.value;

  body.querySelectorAll("tr").forEach((row) => {
    const code = Number(row.getAttribute("data-code"));
    const text = row.textContent.toLowerCase();
    const inRange = range === "all" || (code >= 32 && code <= 126);
    const matches = !query || text.includes(query);
    row.style.display = inRange && matches ? "" : "none";
  });
};

const bindTableFilters = () => {
  const searchInput = document.getElementById("tableSearch");
  const rangeSelect = document.getElementById("rangeSelect");
  if (!searchInput || !rangeSelect) return;

  searchInput.addEventListener("input", filterTable);
  rangeSelect.addEventListener("change", filterTable);
};

const initLangSwitch = () => {
  document.querySelectorAll("[data-lang]").forEach((btn) => {
    btn.addEventListener("click", () => setLanguage(btn.getAttribute("data-lang")));
  });
};

const initNavToggle = () => {
  const toggle = document.querySelector(".nav-toggle");
  const nav = document.querySelector(".nav");
  const links = document.querySelectorAll(".nav-links a");
  if (!toggle || !nav) return;

  toggle.addEventListener("click", () => {
    const isOpen = nav.classList.toggle("nav-open");
    toggle.setAttribute("aria-expanded", String(isOpen));
  });

  links.forEach((link) => {
    link.addEventListener("click", () => {
      if (nav.classList.contains("nav-open")) {
        nav.classList.remove("nav-open");
        toggle.setAttribute("aria-expanded", "false");
      }
    });
  });
};

const init = () => {
  initTheme();
  setLanguage(state.lang);
  initLangSwitch();
  initNavToggle();
  bindConverters();
  renderTable();
  bindTableFilters();
};

document.addEventListener("DOMContentLoaded", init);
